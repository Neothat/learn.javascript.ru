'use strict'

// ### Способы записи числа
let billionV1 = 1000000000;
let billionV2 = 1_000_000_000;

let billionV3 = 1e9;  // 1 миллиард, буквально: 1 и 9 нулей
alert(7.3e9);  // 7.3 миллиарда (7,300,000,000)

1e3 === 1 * 1000 // e3 означает *1000
1.23e6 === 1.23 * 1000000 // e6 означает *1000000

let mcs = 0.000001;
let ms = 1e-6; // шесть нулей слева от 1

// 1 делится на 1 с 3 нулями
1e-3 === 1 / 1000 //(=0.001)

// 1.23 делится на 1 с 6 нулями
1.23e-6 === 1.23 / 1000000 //(=0.00000123)
// ###

// ### Шестнадцатеричные, двоичные и восьмеричные числа
alert(0xff); // 255
alert(0xFF); // 255 (то же самое, регистр не имеет значения)

let a = 0b11111111; // двоичная (бинарная) форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255
alert(a == b); // true, с двух сторон число 255
// ###

// ### toString(base)
let numBase = 255;

alert(numBase.toString(16));  // ff
alert(numBase.toString(2));   // 11111111

alert(123456..toString(36)); // 2n9c
// Если мы поставим одну точку: 123456.toString(36), тогда это будет ошибкой, поскольку синтаксис JavaScript предполагает, 
// что после первой точки начинается десятичная часть. 
// А если поставить две точки, то JavaScript понимает, что десятичная часть отсутствует, и начинается метод.
// ###

// ### Округление
alert(Math.floor(3.1)); // 3
alert(Math.floor(-1.1)); // -2
alert(Math.ceil(3.1)); // 4
alert(Math.ceil(-1.1)); // -1
alert(Math.round(3.1)); // 3
alert(Math.round(3.6)); // 4
alert(Math.round(-1.1)); // -1
alert(Math.trunc(3.1)); // 3
alert(Math.trunc(-1.1)); // -1

// Метод toFixed(n) округляет число до n знаков после запятой и возвращает строковое представление результата.
// Округляет значение до ближайшего числа, как в большую, так и в меньшую сторону, аналогично методу Math.round
let numRound1 = 12.34;
alert(numRound1.toFixed(1)); // "12.3"

let numRound2 = 12.36;
alert(numRound2.toFixed(1)); // "12.4"

let numRound3 = 12.34;
alert(numRound3.toFixed(5)); // "12.34000", добавлены нули, чтобы получить 5 знаков после запятой

// Мы можем преобразовать полученное значение в число, используя унарный оператор + или Number(), пример с унарным оператором +.
alert(+numRound3.toFixed(5));
// ###

// ### Неточные вычисления
alert(0.1 + 0.2 == 0.3); // false
alert(0.1 + 0.2); // 0.30000000000000004

// Число хранится в памяти в бинарной форме, как последовательность бит – единиц и нулей. 
// Но дроби, такие как 0.1, 0.2, которые выглядят довольно просто в десятичной системе счисления, 
// на самом деле являются бесконечной дробью в двоичной форме.

let sum = 0.1 + 0.2;
alert(sum.toFixed(2)); // 0.30
alert(+sum.toFixed(2)); // 0.3

// Привет! Я – число, растущее само по себе!
alert(9999999999999999); // покажет 10000000000000000
// Причина та же – потеря точности. Из 64 бит, отведённых на число, сами цифры числа занимают до 52 бит, 
// остальные 11 бит хранят позицию десятичной точки и один бит – знак. 
// Так что если 52 бит не хватает на цифры, то при записи пропадут младшие разряды.

// Другим забавным следствием внутреннего представления чисел является наличие двух нулей: 0 и -0.
// Все потому, что знак представлен отдельным битом, так что, любое число может быть положительным и отрицательным, включая нуль.
// ###

// ### Проверка: isFinite и isNaN
// isNaN(value) преобразует значение в число и проверяет является ли оно NaN:

alert(isNaN(NaN)); // true
alert(isNaN("str")); // true

// isFinite(value) преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е. не NaN/Infinity/-Infinity:
alert(isFinite("15")); // true
alert(isFinite("str")); // false, потому что специальное значение: NaN
alert(isFinite(Infinity)); // false, потому что специальное значение: Infinity

let num = +prompt("Введите число:", '');
// вернёт true всегда, кроме ситуаций, когда аргумент - Infinity/-Infinity или не число
alert(isFinite(num));

// Number.isNaN(value) возвращает true только в том случае, если аргумент принадлежит к типу number и является NaN. Во всех остальных случаях возвращает false.
alert(Number.isNaN(NaN)); // true
alert(Number.isNaN("str" / 2)); // true

// Обратите внимание на разный результат:
alert(Number.isNaN("str")); // false, так как "str" является строкой, а не числом
alert(isNaN("str")); // true, так как isNaN сначала преобразует строку "str" в число и в результате преобразования получает NaN

// Number.isFinite(value) возвращает true только в том случае, если аргумент принадлежит к типу number и не является NaN/Infinity/-Infinity. 
// Во всех остальных случаях возвращает false.
alert(Number.isFinite(123)); // true
alert(Number.isFinite(Infinity)); // false
alert(Number.isFinite(2 / 0)); // false

// Обратите внимание на разный результат:
alert(Number.isFinite("123")); // false, так как "123" является строкой, а не числом
alert(isFinite("123")); // true, так как isFinite сначала преобразует строку "123" в число 123
// ###

// ### parseInt и parseFloat
alert(parseInt('100px')); // 100
alert(parseFloat('12.5em')); // 12.5

alert(parseInt('12.3')); // 12, вернётся только целая часть
alert(parseFloat('12.3.4')); // 12.3, произойдёт остановка чтения на второй точке

alert(parseInt('a123')); // NaN, на первом символе происходит остановка чтения
// ###

// ### Другие математические функции

// Возвращает псевдослучайное число в диапазоне от 0 (включительно) до 1 (но не включая 1)
alert(Math.random()); // 0.1234567894322
alert(Math.random()); // 0.5435252343232
alert(Math.random()); // ... (любое количество псевдослучайных чисел)

// Возвращает наибольшее / наименьшее число из перечисленных аргументов.
alert(Math.max(3, 5, -10, 0, 1)); // 5
alert(Math.min(1, 2)); // 1

// Возвращает число n, возведённое в степень power
alert(Math.pow(2, 10)); // 2 в степени 10 = 1024
// ###